
# 我认为的图像组主要问题

## 问题
> 1. 写代码能力差
> 2. **没有养成良好的编程习惯**（导致团队传承能力差，每年都像是第一次参加比赛。同时导致代码维护困难，浪费了大量时间）
> 3. 某些毫无意义的争论缺乏决断。用什么版本的库，写 C++ 还是 C 有什么好争的
> 4. 频繁开会

## 解决
### 问题1
无解。
### 问题2
请看我提供的 C++ 代码规范
### 问题3
|环境|版本|理由|
|-|-|-|
|Ubuntu|16.04 LTS||
|Onboard Computer|mini-PC等|尽量用 x86 架构的，Ubuntu 对 armhf 只有 Server 版本，内核模块非常精简，需要手动编译内核模块，以及各种玄学问题|
|项目工程|CMake|CMake可以生成多种 IDE 的项目文件，可以方便的在 VS、Eclipse 等切换，且便于跨平台编译|
|IDE|随意|请不要用记事本写代码，如果有人用记事本写代码就踢了他（代码量10W以上的除外）|
|C++|-std=c++11|c++11 是现代 c++ 的标志，今年是 2017 年，请抛弃已经过时的教科书，用现代的 c++ 语法编程|
|OpenCV|3.2.x|今年2017|
|OpenCV API|C++接口|禁止使用 C 风格 API，需要手动管理内存|
|Eigen|Stable||
|gRPC|Stable|远程调用|
### 问题4
我认为频繁的开会是没有意义的，有一段时间，图像组的同学们9点到实验室，半个小时开机，再聊天半个小时，等到10点开会询问进度所有人都说没问题。然而事实是怎样？写的乱七八糟的代码根本没办法维护，直到要去深圳的前一天程序居然还有至少多处逻辑错误、多线程冲突甚至 segment fault，对于咱们写代码的人来说，程序写崩溃绝对绝对是无法容忍的错误，尤其是不到 2000 行的代码也能写崩溃，简直是不可思议。**程序跑 10 次，2 次成功 7 次误识别 1 次崩溃，开会汇报的时候简称为成功，开这样的会有什么意义**？

-----
## 附录1：C++ 代码规范
### 数据类型
```C++
// 错误，请弃用 buildin 类型
unsigned idx = 0;

// 正确，由于代码需要在不同的设备环境（x64, x86, armhf, gcc, msvc）下运行，有时还需要与电控通信
// 因此应该使用 stdint.h 中具备明确位数标识的类型定义
#include <stdint.h>
uint32_t idx = 0;
// 对于一些只是临时使用的变量，例如 for 循环中的 int i = 0 是可以的
```

### 变量和函数命名
```C++
// 错误，不要使用拼音作为变量名
int shu = 0;
// 正确
int32_t n_points = 0;

// 错误，不要使用莫名其妙或者有多重意义的简写，rst有可能是 result 或 reset
#define rst_dealnum 3
// 正确
#define result_dealnum 3
// 正确，idx 是 index 的惯用简写，且此简写保留辅音字母，不会与其他单词混淆
uint32_t idx= 0;

// 正确，变量名可以长点，但是一定要表达清楚
int32_t idx_of_filtered_points = 0;

// 正确，函数命名清晰明了一看就懂
std::vector<Text> fuck_error_imgs_off(std::vector<Text> &found_rect, int target_rows, int target_cols);

// 错误，不要用这种莫名其妙的文件名
wtw.h
wtw.cpp

// 正确，另外建议文件名只使用小写字母和下划线
armor_tracking.h
armor_tracking.cpp
```

### 函数调用
```C++
// 错误，一个函数应该尽量少访问全局变量，且应该通过参数传递实现数据处理
int32_t src;
int32_t dst;
void process()
{
    dst = src;
}
// 正确
void process(int32_t src, int32_t &dst)
{
    dst = src;
}

// 错误，class 作为参数传递时，应该传递引用以减少一次构造耗时
cv::Point2f match_points(cv::Mat src);
// 正确
cv::Point2f match_points(const cv::Mat &src);
```

### 返回值
```C++
// 错误，不要在代码块内部返回，这样有可能漏掉一些判断
bool process()
{
    if (1)
        return true;
    else if (2)
        return false;
    else
    {
        if (3)
            return true;
    }
}

// 正确
bool process()
{
    bool y = false;
    if (1)
        y = true;
    else if (2)
        y = false;
    else
    {
        if (3)
            y = true;
    }
    return y;
}
```

### 类
```C++
class Node // 类名大写
{
public:
    Node(const std::string &pip) : pip_(pip)
    {
        fd_ = fopen("xxx");
        if (0 == fd_)
            throw std::runtime_error("Can not open file xxx"); //如果构造无返回值，出错应该直接抛出异常
    }
private:
    std::string pip_; // 类成员变量以下划线结尾，便于区分临时变量，在初始化的时候方便构造
    FILE *fd_;
};
```

### 命名空间
```C++
// 对于多人写的多个子程序，可以在程序最外层用命名空间包起来，这样可以避免重名问题，且可以将代码落实到人
name space wang
{
cv::Point2f process(cv::Mat src)
{
...
}
}

// 使用时
cv::Point2f result = wang::process(src);
```

### 多线程
```C++
// 对于图像处理类 CPU 密集形的程序，多线程使用我提供的此种方法效率最高
// 我将这种方法称为“流水线处理法”
// 另外需要说明的是，只要前期代码封装的足够好，到了最后改成多线程是十分方便的
// 因此可以说，多线程起到的作用的锦上添花，而不是雪中送碳
// 如果代码单线程都跑着有问题，那么使用多线程毫无意义

std::thread *thread_read_frame = nullptr;
std::thread *thread_preprocess = nullptr;
std::thread *thread_main_tasks_1 = nullptr;
std::thread *thread_main_tasks_2 = nullptr;

bool stop_flag = 0;

cv::Mat img_raw;
cv::Mat img_edge;
std::vector<std::vector<cv::Point>> final_counters;

// 线程锁的逻辑是此类多线程程序的核心
// 每一个数据块使用两个锁，分别是读锁和写锁
// 程序的运行逻辑是：
// 1
// 2
// 3-1
// 4-2
// 5-3-1
// 6-4-2
// 1-5-3
// 2-6-4
// 3-1-5
// 4-2-6
// 如果在每一个线程中依次 print 出 1234，那么：
// 单线程输出：123412341234
// 多线程输出：123412341234
// 区别是，多线程在 2 执行时可以瞬间从 1 拿到数据
// 或者说，1-2 这一段时间变快了，但总体逻辑是不会乱的
std::mutex img_raw_ready_to_read;
std::mutex img_raw_ready_to_write;
std::mutex img_edge_ready_to_read;
std::mutex img_edge_ready_to_write;
std::mutex vec_final_ready_to_read;
std::mutex vec_final_ready_to_write;

// 第一个流水线，读图
void read_frame(int id)
{
	cv::VideoCapture capture(0);
	cv::Mat frame;
	if (!capture.isOpened())
	{
		std::cout << "error opening video" << std::endl;
		return;
	}
	while (1)
	{
		img_raw_ready_to_write.lock();
		//
		capture >> frame;
		cv::cvtColor(frame, img_raw, CV_BGR2GRAY);
		//
		img_raw_ready_to_read.unlock();
		//
		if (stop_flag)
			break;
	}
}

// 第二个流水线，预处理
void preprocess(int id)
{
	while (1)
	{
		img_raw_ready_to_read.lock();
		img_edge_ready_to_write.lock();
		//
		cv::medianBlur(img_raw, img_edge, 5);
		cv::GaussianBlur(img_raw, img_edge, cv::Size(5, 5), 0, 0);
		cv::adaptiveThreshold(img_raw, img_edge, 255,
				cv::ADAPTIVE_THRESH_GAUSSIAN_C, cv::THRESH_BINARY, 7, 5);
		//
		img_raw_ready_to_write.unlock();
		img_edge_ready_to_read.unlock();
		//
		if (stop_flag)
			break;
	}
}

// 第三个流水线，密集运算
void main_tasks_1(int id)
{
	while (1)
	{
		img_edge_ready_to_read.lock();
		vec_final_ready_to_write.lock();
		//
		std::vector<std::vector<cv::Point>> original_contours;
		std::vector<cv::Vec4i> hierarchy;
		std::vector<cv::Rect> original_rects;
		cv::findContours(img_edge, original_contours, hierarchy, CV_RETR_TREE,
				CV_CHAIN_APPROX_SIMPLE);
		final_counters = original_contours;
		//
		img_edge_ready_to_write.unlock();
		vec_final_ready_to_read.unlock();
		//
		if (stop_flag)
			break;
	}
}

int multi_thread_f = 0;

// 第四个流水线，密集运算
void main_tasks_2(int id)
{
	while (1)
	{
		vec_final_ready_to_read.lock();
		//
		for (auto it = final_counters.begin(); it != final_counters.end(); it++)
		{
			int a = 0;
			a++;
		}
		//
		vec_final_ready_to_write.unlock();
		multi_thread_f++;
		//
		if (stop_flag)
			break;
	}
}

// 测试多线程
void test_multi_thread()
{
	int64 tick_start = cv::getTickCount();
	//
	img_raw_ready_to_read.lock();
	img_edge_ready_to_read.lock();
	vec_final_ready_to_read.lock();
	thread_read_frame = new std::thread(read_frame, 1);
	thread_preprocess = new std::thread(preprocess, 2);
	thread_main_tasks_1 = new std::thread(main_tasks_1, 3);
	thread_main_tasks_2 = new std::thread(main_tasks_2, 4);

	std::this_thread::sleep_for(std::chrono::seconds(10));
	//
	int64 tick_end = cv::getTickCount();
	float real_time = (tick_end - tick_start) / cv::getTickFrequency();
	std::cout << "multi thread: " << multi_thread_f / real_time << " fps"
			<< std::endl;
	stop_flag = 1;
	thread_read_frame->join();
	thread_preprocess->join();
	thread_main_tasks_1->join();
	thread_main_tasks_2->join();

	delete thread_read_frame;
	delete thread_preprocess;
	delete thread_main_tasks_1;
	delete thread_main_tasks_2;
}

// 测试单线程
void test_single_thread()
{
	int64 tick_start = cv::getTickCount();
	//
	cv::VideoCapture capture(0);
	cv::Mat frame;
	if (!capture.isOpened())
	{
		std::cout << "error opening video" << std::endl;
		return;
	}
	for (int i = 0; i < 200; i++)
	{
		capture >> frame;
		cv::cvtColor(frame, img_raw, CV_BGR2GRAY);
		//
		cv::medianBlur(img_raw, img_edge, 5);
		cv::GaussianBlur(img_raw, img_edge, cv::Size(5, 5), 0, 0);
		cv::adaptiveThreshold(img_raw, img_edge, 255,
				cv::ADAPTIVE_THRESH_GAUSSIAN_C, cv::THRESH_BINARY, 7, 5);
		//
		std::vector<std::vector<cv::Point>> original_contours, final_counters;
		std::vector<cv::Vec4i> hierarchy;
		std::vector<cv::Rect> original_rects;
		cv::findContours(img_edge, original_contours, hierarchy, CV_RETR_TREE,
				CV_CHAIN_APPROX_SIMPLE);
		for (auto it = final_counters.begin(); it != final_counters.end(); it++)
		{
			int a = 0;
			a++;
		}
		final_counters = original_contours;
	}
	//
	int64 tick_end = cv::getTickCount();
	float real_time = (tick_end - tick_start) / cv::getTickFrequency();
	std::cout << "single thread: " << 200 / real_time << " fps" << std::endl;
}

int main()
{
	test_single_thread();
	test_multi_thread();
	return 0;
}
```
-----
