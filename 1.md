
# 给下一届的建议

## 问题
我认为图像组最主要的问题是以下几点
> 1. 写代码能力差
> 2. 没有养成良好的写代码习惯（导致团队传承能力差，每年都像是第一次参加比赛。同时导致代码维护困难，浪费了大量时间）
> 3. 某些毫无意义的争论缺乏决断。用什么版本的库，写 C++ 还是 C 有什么好争的
> 4. 频繁开会

## 解决
### 问题1
无解。
### 问题2
请看我提供的 C++ 代码规范
### 问题3
|环境|版本|理由|
|-|-|-|
|Ubuntu|16.04 LTS||
|Onboard Computer|mini-PC等|尽量用 x86 架构的，Ubuntu 对 armhf 只有 Server 版本，内核模块非常精简，需要手动编译内核模块，以及各种玄学问题|
|项目工程|CMake|CMake可以生成多种 IDE 的项目文件，可以方便的在 VS、Eclipse 等切换，且便于跨平台编译|
|IDE|随意|请不要用记事本写代码，如果有人用记事本写代码就踢了他（代码量10W以上的除外）|
|C++|-std=c++11|c++11 是现代 c++ 的标志，今年是 2017 年，请抛弃已经过时的教科书，用现代的 c++ 语法编程|
|OpenCV|3.2.x|今年2017|
|OpenCV API|C++接口|禁止使用 C 风格 API，需要手动管理内存|
|Eigen|Latest Stable||
### 问题4
我认为频繁的开会是没有意义的，有一段时间，图像组的同学们9点到实验室，半个小时开机，再聊天半个小时，等到10点开会询问进度所有人都说没问题。然而事实是怎样？写的乱七八糟的代码根本没办法维护，直到要去深圳的前一天程序居然还有至少多处逻辑错误、多线程冲突甚至 segment fault，对于咱们写代码的人来说，程序写崩溃绝对绝对是无法容忍的错误，尤其是不到 2000 行的代码也能写崩溃，简直是不可思议。**程序跑 10 次，2 次成功 7 次误识别 1 次崩溃，开会汇报的时候简称为成功，开这样的会有什么意义**？

-----
## 附录1：C++ 代码规范
### 数据类型
```C++
// 错误，请弃用 buildin 类型
unsigned idx = 0;

// 正确，由于代码需要在不同的设备环境（x64, x86, armhf, gcc, msvc）下运行，有时还需要与电控通信
// 因此应该使用 stdint.h 中具备明确位数标识的类型定义
#include <stdint.h>
uint32_t idx = 0;
// 对于一些只是临时使用的变量，例如 for 循环中的 int i = 0 是可以的
```

### 变量和函数命名
```C++
// 错误，不要使用拼音作为变量名
int shu = 0;
// 正确
int32_t n_points = 0;

// 错误，不要使用莫名其妙或者有多重意义的简写，rst有可能是 result 或 reset
#define rst_dealnum 3
// 正确
#define result_dealnum 3
// 正确，idx 是 index 的惯用简写，且此简写保留辅音字母，不会与其他单词混淆
uint32_t idx= 0;

// 正确，变量名可以长点，但是一定要表达清楚
int32_t idx_of_filtered_points = 0;

// 正确，函数命名清晰明了一看就懂
std::vector<Text> fuck_error_imgs_off(std::vector<Text> &found_rect, int target_rows, int target_cols);

// 错误，不要用这种莫名其妙的文件名
wtw.h
wtw.cpp

// 正确，另外建议文件名只使用小写字母和下划线
armor_tracking.h
armor_tracking.cpp
```

### 函数调用
```C++
// 错误，一个函数应该尽量少访问全局变量，且应该通过参数传递实现数据处理
int32_t src;
int32_t dst;
void process()
{
    dst = src;
}
// 正确
void process(int32_t src, int32_t dst)
{
    dst = src;
}

// 错误，class 作为参数传递时，应该传递引用以减少一次构造耗时
cv::Point2f match_points(cv::Mat src);
// 正确
cv::Point2f match_points(const cv::Mat &src);
```

### 返回值
```C++
// 错误，不要在代码块内部返回，这样有可能漏掉一些判断
bool process()
{
    if (1)
        return true;
    else if (2)
        return false;
    else
    {
        if (3)
            return true;
    }
}

// 正确
bool process()
{
    bool y = false;
    if (1)
        y = true;
    else if (2)
        y = false;
    else
    {
        if (3)
            y = true;
    }
    return y;
}
```

### 类
```C++
class Node // 类名大写
{
public:
    Node(const std::string &pip) : pip_(pip)
    {
        fd_ = fopen("xxx");
        if (0 == fd_)
            throw std::runtime_error("Can not open file xxx"); //如果构造函数出错没办法返回，应该直接抛出异常
    }
private:
    std::string pip_; // 类成员变量以下划线结尾，便于区分临时变量，在初始化的时候方便构造
    FILE *fd_;
};
```
-----
